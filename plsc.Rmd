---
title: "ABCD-PLSC-Ap-GM-Rscript"
author:"Chloe Hampson, Taylor Jancetic, Kirthana"
date: "2024-09-30"
output:
  html_document:
    fontsize : 9 pt
    theme: united
    code_folding: hide
    toc: true
    toc_float: true
    toc_depth: 6
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Intallment and loading of packages
```{r}
# Utility functions for package management
install_cran_if_missing <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    message(sprintf("Installing CRAN package: %s", pkg))
    install.packages(pkg)
  }
}

install_github_if_missing <- function(pkg, repo) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    if (!requireNamespace("devtools", quietly = TRUE)) {
      install.packages("devtools")
    }
    message(sprintf("Installing GitHub package: %s from %s", pkg, repo))
    devtools::install_github(repo)
  }
}

# -
# Load Packages

cran_packages <- c(
  "tidyverse", "dplyr", "readr", "here", 
  "ggplot2", "cowplot", "corrplot", "gridExtra", "grid","reshape2",
  "ExPosition", "TExPosition", "psych", "car", "kableExtra"
)

github_packages <- c("PTCA4CATA", "data4PCCAR")
github_repos <- c("HerveAbdi/PTCA4CATA", "HerveAbdi/data4PCCAR")

# Install & load
invisible(lapply(cran_packages, install_cran_if_missing))
invisible(mapply(install_github_if_missing, github_packages, github_repos))
invisible(lapply(c(cran_packages, github_packages), library, character.only = TRUE))

```


**Data :**  cleaned data, pre processed and grouped into two different datasets - one for RSI measures and other for sociocultural measures from ABCD data.


## 2. Directories & Data
```{r}


proj_dir <- here::here()
fig_dir <- file.path(proj_dir, "derivatives/gn-reduced/figures")
out_dir <- file.path(proj_dir, "derivatives/gn-reduced")

covar_df <- read_csv("D:/Hunor/phd_project/Brain_hack/abide-plsc/simulated_covariate.csv")
socio_df <- read_csv("D:/Hunor/phd_project/Brain_hack/abide-plsc/simulated_sociocult.csv")
rsfc_df  <- read_csv("D:/Hunor/phd_project/Brain_hack/abide-plsc/simulated_rsfc.csv")


```

# 3. Residualization of data
```{r}

# function for residualization
run_residualization <- function(y, covar_df) {
  lm_fit <- lm(
    y ~ interview_age +
      as.factor(demo_sex_v2) +
      demo_prnt_age_v2 +
   #   as.factor(demo_prnt_gender_id_v2) +
      demo_prnt_ed_v2_2yr_l +
      demo_prtnr_ed_v2_2yr_l +
      demo_comb_income_v2 +
    #  as.factor(demo_origin_v2) +
      as.factor(site_id_l) +
      as.factor(mri_info_manufacturer) +
      rsfmri_meanmotion,
    data = covar_df,
    na.action = na.omit
  )
  return(as.data.frame(residuals(lm_fit)))
}

#rezidualization of data
Group1_residuals <- run_residualization(as.matrix(rsfc_df), covar_df)
Group2_residuals <- run_residualization(as.matrix(socio_df), covar_df)
```



#### Measure goodness of fit

```{r echo=TRUE}
fit_resi <- paste0(fig_dir, "resi-fit_rsfc.png") # Correct file path with slash

# Open the PNG device to save the plots
png(fit_resi, height = 600, width = 1800) # Set dimensions in pixels

# Set up a 3x2 grid layout (3 rows, 2 columns)
par(mfrow = c(1, 3))

# Q-Q plot for residuals
qqnorm(Group1_residuals[, 1], main = "Q-Q plot for RSFC residuals")
qqline(Group1_residuals[, 1])

# Histogram of residuals (using base hist function)
hist(Group1_residuals[, 1], main = "Histogram of RSFC residuals", xlab = "Residuals", col = "lightblue")

# Evaluation by prediction
f1 <- fitted(lm.Group1)
r1 <- residuals(lm.Group1)

# Fitted vs residual plot
plot(f1, r1, main = "Fitted vs. RSFC Residuals")

# Reset plotting layout (optional)
par(mfrow = c(1, 1))

# Close the PNG device to save the plot
dev.off()
```


#### Measure goodness of fit


```{r echo=TRUE}
fit_resi <- paste0(fig_dir, "resi-fit_socio.png") # Correct file path with slash

# Open the PNG device to save the plots
png(fit_resi, height = 600, width = 1800) # Set dimensions in pixels

# Set up a 1x3 grid
par(mfrow = c(1, 3))

# Q-Q plot for residuals
qqnorm(Group2_residuals[, 1], main = "Q-Q plot for Sociocultural residuals")
qqline(Group2_residuals[, 1])

# Histogram of residuals (using base hist function)
hist(Group2_residuals[, 1], main = "Histogram of Sociocultural residuals", xlab = "Residuals", col = "lightblue")

# Evaluation by prediction
f2 <- fitted(lm.Group2)
r2 <- residuals(lm.Group2)

# Fitted vs residual plot
plot(f2, r2, main = "Fitted vs. Sociocultural Residuals")

# Reset plotting layout (optional)
par(mfrow = c(1, 1))

# Close the PNG device to save the plot
dev.off()
```

```{r}
# Define the file path to save the Q-Q plot PNG
fit_resi <- paste0(fig_dir, "qq-plots_residuals.png") # Correct file path with slash

# Open the PNG device to save the plots
png(fit_resi, height = 800, width = 1200) # Set dimensions in pixels

# Set up the grid to display Q-Q plots in 2 rows
par(mfrow = c(3, ceiling(ncol(Group2_residuals) / 3))) # 2 rows and adjust number of columns based on residuals

# Loop through each column in Group2_residuals to create Q-Q plots
for (i in 1:ncol(Group2_residuals)) {
  # Q-Q plot for residuals
  qqnorm(Group2_residuals[, i], main = paste0("Q-Q plot for ", colnames(Group2_residuals)[i]))
  qqline(Group2_residuals[, i]) # Add the Q-Q line
}

# Reset plotting layout (optional)
par(mfrow = c(1, 1))

# Close the PNG device to save the plot
dev.off()

```

```{r}
# Define the file path to save the scatter plot PNG
fit_resi <- paste0(fig_dir, "scatter-plots_residuals.png") # Correct file path with slash

# Open the PNG device to save the plots
png(fit_resi, height = 800, width = 1200) # Set dimensions in pixels

# Set up the grid to display scatter plots in 2 rows
par(mfrow = c(3, ceiling(ncol(Group2_residuals) / 3))) # 2 rows and adjust number of columns based on residuals

# Loop through each column in Group2_residuals to create scatter plots
for (i in 1:ncol(Group2_residuals)) {
  # Scatter plot for residuals vs index (or fitted values, or another variable)
  plot(Group2_residuals[, i],
    main = paste0("Scatter plot for ", colnames(Group2_residuals)[i]),
    xlab = "Index", ylab = "Residuals",
    pch = 19, col = "blue"
  )
}

# Reset plotting layout (optional)
par(mfrow = c(1, 1))

# Close the PNG device to save the plot
dev.off()
```


## 5. PLSC Analysis


```{r}
# 1. Run PLSC Analysis
# Re-define the lm function to get a complete lm object for later use
run_residualization_lm <- function(y, covar_df) {
  lm_fit <- lm(
    y ~ interview_age +
      as.factor(demo_sex_v2) +
      demo_prnt_age_v2 +
      demo_prnt_ed_v2_2yr_l +
      demo_prtnr_ed_v2_2yr_l +
      demo_comb_income_v2 +
      as.factor(site_id_l) +
      as.factor(mri_info_manufacturer) +
      rsfmri_meanmotion,
    data = covar_df,
    na.action = na.omit
  )
  return(lm_fit)
}

lm.Group1 <- run_residualization_lm(as.matrix(rsfc_df), covar_df)
lm.Group2 <- run_residualization_lm(as.matrix(socio_df), covar_df)
data1 <- as.data.frame(residuals(lm.Group1))
data2 <- as.data.frame(residuals(lm.Group2))

# Create a design matrix for the PLSC analysis
design_matrix <- as.matrix(as.factor(covar_df$site_id_l))
rownames(design_matrix) <- covar_df$src_subject_id

# Run the core PLSC analysis
pls.res <- tepPLS(
  data1, data2,
  DESIGN = design_matrix,
  make_design_nominal = TRUE,
  graphs = FALSE # Set graphs to FALSE to create custom plots
)
summary(pls.res)
```
```{r}
# 2. Correlation Plot
# Create the correlation matrix
XY.cor.pearson <- cor(data2, data1)

# Reshape the correlation matrix for ggplot
cor_df <- reshape2::melt(XY.cor.pearson)

# Create the ggplot heatmap
cor_plot <- ggplot(cor_df, aes(x = Var2, y = Var1, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low = "darkred", mid = "white", high = "midnightblue",
    midpoint = 0, limits = c(-0.25, 0.25)
  ) +
  labs(title = "Pearson Correlation Matrix", x = "RSFC Measures", y = "Sociocultural Measures", fill = "Correlation") +
  theme_minimal(base_size = 10) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    legend.position = "bottom"
  )

# Save the plot
ggsave(file.path(fig_dir, "correlation_plot.png"), plot = cor_plot, width = 10, height = 8, dpi = 300)

# Display the plot in the R Markdown output
knitr::include_graphics(file.path(fig_dir, "correlation_plot.png"))
```


```{r}
# 3. Permutation Test and Scree Plot
# Run permutation test to find significant dimensions
resPerm4PLSC <- perm4PLSC(data1, data2, permType = "byColumns", nIter = 10000)

# Create a data frame for the scree plot
scree_df <- data.frame(
  Dimension = 1:length(pls.res$TExPosition.Data$eigs),
  Eigenvalue = pls.res$TExPosition.Data$eigs,
  p_value = resPerm4PLSC$pEigenvalues
)

# Identify significant dimensions
scree_df$Significance <- ifelse(scree_df$p_value < 0.05, "Significant", "Not Significant")
significant_dims <- sum(scree_df$p_value < 0.05)

# Create a scree plot using ggplot2
scree_plot <- ggplot(scree_df, aes(x = Dimension, y = Eigenvalue)) +
  geom_bar(stat = "identity", aes(fill = Significance), color = "black") +
  geom_point(aes(color = Significance), size = 4) +
  geom_line(aes(color = Significance, group = 1)) +
  scale_fill_manual(values = c("Significant" = "red", "Not Significant" = "grey")) +
  scale_color_manual(values = c("Significant" = "red", "Not Significant" = "black")) +
  labs(
    title = paste("PLSC Scree Plot with", significant_dims, "Significant Dimensions"),
    x = "Latent Dimension", y = "Eigenvalue (Inertia)"
  ) +
  theme_minimal() +
  geom_text(aes(label = round(Eigenvalue, 2)), vjust = -1, size = 3) +
  guides(fill = "none", color = "none")

# Save the plot
ggsave(file.path(fig_dir, "PLSC_Scree_Plot.png"), plot = scree_plot, width = 8, height = 6, dpi = 300)

# Display the plot
knitr::include_graphics(file.path(fig_dir, "PLSC_Scree_Plot.png"))
```
```{r}
# Re-run PLSC analysis (as provided in your script)
pls.res <- tepPLS(
  data1, data2,
  DESIGN = design_matrix,
  make_design_nominal = TRUE,
  graphs = FALSE # Set graphs to FALSE to create custom plots
)

# Run permutation test with 10000 iterations
resPerm4PLSC <- perm4PLSC(
  data1,
  data2,
  permType = "byColumns",
  nIter = 10000
)

# Print permutation test results
print(resPerm4PLSC)
```
```{r}
# Create a data frame for the scree plot
scree_df <- data.frame(
  Dimension = 1:length(pls.res$TExPosition.Data$eigs),
  Eigenvalue = pls.res$TExPosition.Data$eigs,
  p_value = resPerm4PLSC$pEigenvalues
)

# Identify significant dimensions (p < 0.05)
scree_df$Significance <- ifelse(scree_df$p_value < 0.05, "Significant", "Not Significant")
significant_dims <- sum(scree_df$p_value < 0.05)

# Create a scree plot using ggplot2
scree_plot <- ggplot(scree_df, aes(x = Dimension, y = Eigenvalue)) +
  geom_bar(stat = "identity", aes(fill = Significance), color = "black") +
  geom_point(aes(color = Significance), size = 4) +
  geom_line(aes(color = Significance, group = 1)) +
  scale_fill_manual(values = c("Significant" = "red", "Not Significant" = "grey")) +
  scale_color_manual(values = c("Significant" = "red", "Not Significant" = "black")) +
  labs(
    title = paste("PLSC Scree Plot with", significant_dims, "Significant Dimensions"),
    x = "Latent Dimension",
    y = "Eigenvalue (Inertia)"
  ) +
  theme_minimal(base_size = 12) +
  geom_text(aes(label = round(Eigenvalue, 2)), vjust = -1, size = 4) +
  guides(fill = "none", color = "none")

# Save the plot using ggsave
ggsave(file.path(fig_dir, "PLSC_Scree_Plot.png"), plot = scree_plot, width = 8, height = 6, dpi = 300)
# Display the plot in the R Markdown output
knitr::include_graphics(file.path(fig_dir, "PLSC_Scree_Plot.png"))
```
```{r}

# Set the file path for saving the PNG
png(file.path(fig_dir, "Perm_Histograms.png"), width = 2400, height = 800, res = 200)

# Set up the plotting layout
par(mfrow = c(1, 3))

# Loop through the first 3 latent dimensions (or as many as you need)
for (zeDim in 1:3) { # Changed to loop through dimensions 1, 2, and 3 for a better overview
  eigs <- resPerm4PLSC$permEigenvalues[, zeDim]
  obs <- as.numeric(resPerm4PLSC$fixedEigenvalues[zeDim])

  prettyHist(
    distribution = eigs,
    observed = obs,
    breaks = 30,
    border = "white",
    main = paste0("Permutation Test - Latent Dim ", zeDim),
    xlab = paste0("Inertia of samples\nLatent dimension ", zeDim),
    ylab = "Number of samples"
  )
}

# Close the PNG device
dev.off()
# Display the plot in the R Markdown output
knitr::include_graphics(file.path(fig_dir, "Perm_Histograms.png"))

```
```{r}
# Get the latent variables and components
lx <- pls.res$TExPosition.Data$lx
ly <- pls.res$TExPosition.Data$ly
fi <- pls.res$TExPosition.Data$fi
fj <- pls.res$TExPosition.Data$fj
ci <- pls.res$TExPosition.Data$ci
cj <- pls.res$TExPosition.Data$cj

# Combine factor scores and contributions for a single plot
combined_factors <- rbind(fi, fj)
combined_contributions <- rbind(ci, cj)

# Save the Component plot (both sets of variables)
png(file.path(fig_dir, "Component_Plot_All.png"), width = 1000, height = 1000, res = 300)
prettyPlot(
  combined_factors,
  contributionCircles = TRUE,
  contributions = combined_contributions,
  xlab = "Component 1",
  ylab = "Component 2",
  main = "Combined Component Map",
  dev.new = FALSE
)
dev.off()
# Display the plot in the R Markdown output
knitr::include_graphics(file.path(fig_dir, "Component_Plot_All.png"))

```
```{r}
# Save the Component map for X set (RSI measures)
png(file.path(fig_dir, "Component_Map_X_Set.png"), width = 1000, height = 1000, res = 300)
prettyPlot(
  fi,
  contributionCircles = TRUE,
  contributions = ci,
  xlab = "Component 1",
  ylab = "Component 2",
  main = "RSI Component Map",
  dev.new = FALSE
)
dev.off()

# Save the Component map for Y set (Sociocultural measures)
png(file.path(fig_dir, "Component_Map_Y_Set.png"), width = 1000, height = 1000, res = 300)
prettyPlot(
  fj,
  contributionCircles = TRUE,
  contributions = cj,
  xlab = "Component 1",
  ylab = "Component 2",
  main = "Sociocultural Component Map",
  dev.new = FALSE
)
dev.off()
# Display the plots in the R Markdown output
knitr::include_graphics(c(
  file.path(fig_dir, "Component_Map_X_Set.png"),
  file.path(fig_dir, "Component_Map_Y_Set.png")
))

```
```{r}
# Bootstrap analysis
resBoot4PLSC <- Boot4PLSC(
  data1,
  data2,
  nIter = 10000,
  Fi = pls.res$TExPosition.Data$fi,
  Fj = pls.res$TExPosition.Data$fj,
  nf2keep = 5,
  critical.value = 2.5
)

# Get bootstrap ratios
BR.I <- resBoot4PLSC$bootRatios.i
BR.J <- resBoot4PLSC$bootRatios.j

# Determine the number of significant dimensions (e.g., p < 0.05)
significant_dims_count <- sum(resPerm4PLSC$pEigenvalues < 0.05)
print(paste("Number of significant dimensions:", significant_dims_count))

# Plot Bootstrap ratios for the first significant dimension
laDim <- 1 # Assuming the first dimension is significant. You can change this.

# Plot for the X set (RSI measures)
png(file.path(fig_dir, paste0("Bootstrap_Ratio_RSI_Dim", laDim, ".png")), width = 1800, height = 1200, res = 200)
PrettyBarPlot2(
  bootratio = BR.I[, laDim],
  threshold = 2.5,
  font.size = 4,
  ylab = "Bootstrap ratios"
) + ggtitle(paste0("Bootstrap Ratios - RSI Measures, Dimension ", laDim))
dev.off()

# Plot for the Y set (Sociocultural measures)
png(file.path(fig_dir, paste0("Bootstrap_Ratio_Sociocult_Dim", laDim, ".png")), width = 1800, height = 1200, res = 200)
PrettyBarPlot2(
  bootratio = BR.J[, laDim],
  threshold = 2.5,
  font.size = 4,
  ylab = "Bootstrap ratios"
) + ggtitle(paste0("Bootstrap Ratios - Sociocultural Measures, Dimension ", laDim))
dev.off()
# Display the plots in the R Markdown output
knitr::include_graphics(c(
  file.path(fig_dir, paste0("Bootstrap_Ratio_RSI_Dim", laDim, ".png")),
  file.path(fig_dir, paste0("Bootstrap_Ratio_Sociocult_Dim", laDim, ".png"))
))

```

```{r}
# Saving loadings and bootstrap ratios to CSV
socio_loadings <- as.data.frame(pls.res$TExPosition.Data$pdq$q)
rest_loadings <- as.data.frame(pls.res$TExPosition.Data$pdq$p)

socio_res <- cbind.data.frame(socio_loadings, socio_bootstrap)
rni_res <- cbind.data.frame(rest_loadings, rni_bootstrap)

write.csv(socio_res, paste(out_dir, "rni-sociocult_Q-components.csv", sep = "/"), row.names = TRUE)
write.csv(rni_res, paste(out_dir, "rni-brain_P-components.csv", sep = "/"), row.names = TRUE)
write.csv(pls.res$TExPosition.Data$lx, paste(out_dir, "rniXrsfc_lx-base.csv", sep = "/"), row.names = TRUE)
write.csv(pls.res$TExPosition.Data$ly, paste(out_dir, "rniXrsfc_ly-base.csv", sep = "/"), row.names = TRUE)

```
```{r}
# Define a function to create and save a single score plot
save_score_plot <- function(dimension, correlation, file_path) {
  # Create a data frame for the latent variables of the specified dimension
  latvar <- cbind(pls.res$TExPosition.Data$lx[, dimension], pls.res$TExPosition.Data$ly[, dimension])
  colnames(latvar) <- c(
    paste("Latent X dim", dimension),
    paste("Latent Y dim", dimension)
  )
  
  # Create the factor map
  plot.lv <- createFactorMap(latvar, title = paste("Correlation = ", correlation))
  plot_combined <- plot.lv$zeMap_background + plot.lv$zeMap_dots
  
  # Save the plot using ggsave for better quality and control
  ggsave(file_path, plot = plot_combined, width = 6, height = 6, dpi = 300)
}

# --- Create and Save Individual Score Plots ---

# Get correlations for the relevant dimensions
cor_3 <- round(cor(pls.res$TExPosition.Data$lx[, 3], pls.res$TExPosition.Data$ly[, 3]), 3)
cor_4 <- round(cor(pls.res$TExPosition.Data$lx[, 4], pls.res$TExPosition.Data$ly[, 4]), 3)
cor_5 <- round(cor(pls.res$TExPosition.Data$lx[, 5], pls.res$TExPosition.Data$ly[, 5]), 3)

# Save the score plot for dimension 3
save_score_plot(3, cor_3, file.path(fig_dir, "Score_Plot_Dim3.png"))

# Save the score plot for dimension 4
save_score_plot(4, cor_4, file.path(fig_dir, "Score_Plot_Dim4.png"))

# Save the score plot for dimension 5
save_score_plot(5, cor_5, file.path(fig_dir, "Score_Plot_Dim5.png"))

# --- Create a combined plot using grid.arrange (Optional) ---

# Create the plots for each dimension
score3 <- plotScore_fn(3, cor_3)
score4 <- plotScore_fn(4, cor_4)
score5 <- plotScore_fn(5, cor_5)

# Arrange and save the combined plot
combined_score_plot <- cowplot::plot_grid(score3, score4, score5, nrow = 1)
ggsave(file.path(fig_dir, "Score_Plots_Combined.png"), plot = combined_score_plot, width = 18, height = 6, dpi = 300)

# Display the combined plot in the R Markdown output
knitr::include_graphics(file.path(fig_dir, "Score_Plots_Combined.png"))

```



tepPLS(DATA1, DATA2, center1 = TRUE, scale1 = "SS1", center2 = TRUE, scale2 = "SS1", DESIGN = NULL, make_design_nominal = TRUE, graphs = TRUE, k = 0)

DATA1 : Data matrix 1 (X)

DATA2 : Data matrix 2 (Y)

center1 : a boolean, vector, or string to center DATA1. See expo.scale for details.

scale1 : a boolean, vector, or string to scale DATA1. See expo.scale for details.

center2 : a boolean, vector, or string to center DATA2. See expo.scale for details.

scale2 : a boolean, vector, or string to scale DATA2. See expo.scale for details.

DESIGN : a design matrix to indicate if rows belong to groups.

make_design_nominal	: a boolean. If TRUE (default), DESIGN is a vector that indicates groups (and will be dummy-coded). If FALSE, DESIGN is a dummy-coded matrix.

graphs : a boolean. If TRUE (default), graphs and plots are provided (via tepGraphs)

k	: number of components to return.
















 
```{r}
# Define a single function to create and save the loadings map
create_and_save_loadings_map <- function(data, title, file_name, eigs, tau, fig_dir, text_cex) {
  # Generate loadings map
  p.loadings <- createFactorMap(data,
                                axis1 = 1,
                                axis2 = 2,
                                display.points = TRUE,
                                display.labels = TRUE,
                                title = title,
                                pch = 20,
                                cex = 3,
                                text.cex = text_cex)
  
  # Add axis labels
  label4map <- createxyLabels.gen(
    x_axis = 1, y_axis = 2,
    lambda = eigs,
    tau = tau
  )
  
  # Combine plot and labels
  p.plot <- p.loadings$zeMap + label4map
  
  # Save the plot
  ggsave(p.plot,
         file = file.path(fig_dir, file_name),
         width = 10, height = 10, units = "in", dpi = 600)
}

# --- Use the function to plot both datasets ---

# Extract factor scores from the PLSC results
Fi <- pls.res$TExPosition.Data$fi
Fj <- pls.res$TExPosition.Data$fj

# Create and save the loadings map for the RSI measures (data1)
create_and_save_loadings_map(
  data = Fi,
  title = "Loadings of Columns RSI",
  file_name = "rni-brain_factors-components.png",
  eigs = pls.res$TExPosition.Data$eigs,
  tau = pls.res$TExPosition.Data$t,
  fig_dir = fig_dir,
  text_cex = 3
)

# Create and save the loadings map for the sociocultural measures (data2)
create_and_save_loadings_map(
  data = Fj,
  title = "Loadings of Columns Sociocult",
  file_name = "rni-air_factors-components.png",
  eigs = pls.res$TExPosition.Data$eigs,
  tau = pls.res$TExPosition.Data$t,
  fig_dir = fig_dir,
  text_cex = 4
)

# Display the plots in the R Markdown output
knitr::include_graphics(c(
  file.path(fig_dir, "rni-brain_factors-components.png"),
  file.path(fig_dir, "rni-air_factors-components.png")
))
```


### 5. Column Loadings

# These are the loadings obtained after performing SVD(R) on correlation matrix.


# {r echo=TRUE}

# generating bar plots for loadings of RSI data table
```{r}
# Define a function to create and save a bar plot for loadings
create_and_save_loading_barplot <- function(data, title, file_name, fig_dir, horizontal = FALSE, color4ns = "gray75") {
  plot <- PrettyBarPlot2(
    bootratio = data[, 1],
    threshold = 0,
    ylim = NULL,
    color4ns = color4ns,
    plotnames = TRUE,
    main = title,
    ylab = "Loadings",
    horizontal = horizontal
  )
  
  ggsave(plot,
         file = file.path(fig_dir, file_name),
         width = 10, height = 10, units = "in", dpi = 600
  )
}

# --- Use the function to plot both datasets ---

# Get the loadings for each data set
P.data1 <- pls.res$TExPosition.Data$pdq$p
Q.data2 <- pls.res$TExPosition.Data$pdq$q

# Create and save the bar plot for RSI variables
create_and_save_loading_barplot(
  data = P.data1,
  title = "Loadings of RSI variables",
  file_name = "rni-brain_P-components.png",
  fig_dir = fig_dir,
  horizontal = TRUE
)

# Create and save the bar plot for sociocultural variables
create_and_save_loading_barplot(
  data = Q.data2,
  title = "Loadings of sociocult variables",
  file_name = "rni-air_Q-components.png",
  fig_dir = fig_dir,
  horizontal = FALSE,
  color4ns = "white"
)

# Display the plots in the R Markdown output
knitr::include_graphics(c(
  file.path(fig_dir, "rni-brain_P-components.png"),
  file.path(fig_dir, "rni-air_Q-components.png")
))
```




```{r}
# generating bar plots for loadings of Air pollutants data table
Q.data2 <- pls.res$TExPosition.Data$pdq$q
# generating bar plots for loadings of RSI data table
P.data1 <- pls.res$TExPosition.Data$pdq$p

# saving the loading table into excel file.
socio_loadings <- as.data.frame(Q.data2)
rest_loadings <- as.data.frame(P.data1)
```

```{r}
# Looking into what the resBootPLSC is giving us
resBoot4PLSC <- Boot4PLSC(data1, # First Data matrix
  data2, # Second Data matrix
  nIter = 10000, # How many iterations
  Fi = pls.res$TExPosition.Data$fi,
  Fj = pls.res$TExPosition.Data$fj,
  nf2keep = 5, #determines number of dimensions that go into bootstrap
  critical.value = 2.5,
  # To be implemented later
  # has no effect currently
  alphaLevel = 0.5
)

resBoot4PLSC

```

```{r}

BR.I <- resBoot4PLSC$bootRatios.i
BR.J <- resBoot4PLSC$bootRatios.j


# saving the bootstrap rations into excel

socio_bootstrap <- as.data.frame(BR.J)
rni_bootstrap <- as.data.frame(BR.I)

socio_res <- cbind.data.frame(socio_loadings, socio_bootstrap)
rni_res <- cbind.data.frame(rest_loadings, rni_bootstrap)

write.csv(socio_res, paste(out_dir,
  "rni-sociocult_Q-components.csv",
  sep = "/"
), row.names = TRUE)

write.csv(rni_res, paste(out_dir,
  "rni-brain_P-components.csv",
  sep = "/"
), row.names = TRUE)

write.csv(pls.res$TExPosition.Data$lx, paste(out_dir,
  "rniXrsfc_lx-base.csv",
  sep = "/"
), row.names = TRUE)

write.csv(pls.res$TExPosition.Data$ly, paste(out_dir,
  "rniXrsfc_ly-base.csv",
  sep = "/"
), row.names = TRUE)

```

```{r}
if (resPerm4PLSC$pOmnibus < 0.01) {
  for (i in seq_along(resPerm4PLSC$pEigenvalues)) {
    if (resPerm4PLSC$pEigenvalues[i] < 0.01) {
      laDim <- i
    }
  }
}
print(laDim)
```





```{r}
# bootstrap ratios 
laDim <- 4

# Save the plot for BR.I (Component plot)
png(file.path(fig_dir, "Bootstrap_Ratio_BRI_Dim4.png"), width = 1800, height = 1200, res = 200)
PrettyBarPlot2(BR.I[, laDim],
  threshold = 3,
  font.size = 4,
  ylab = "Bootstrap ratios"
  # ylim = c(1.2*min(BR[,laDim]), 1.2*max(BR[,laDim]))
) + ggtitle(paste0("Component ", laDim), subtitle = "Table 1")
dev.off() # Close the PNG device for BR.I

# Save the plot for BR.J (Component plot)
png(file.path(fig_dir, "Bootstrap_Ratio_BRJ_Dim4.png"), width = 1800, height = 1200, res = 200)
PrettyBarPlot2(BR.J[, laDim],
  threshold = 3,
  font.size = 4,
  ylab = "Bootstrap ratios"
  # ylim = c(1.2*min(BR[,laDim]), 1.2*max(BR[,laDim]))
) + ggtitle(paste0("Component ", laDim), subtitle = "Table 2")
dev.off() # Close the PNG device for BR.J
# Display the plots in the R Markdown output
knitr::include_graphics(c(
  file.path(fig_dir, "Bootstrap_Ratio_BRI_Dim4.png"),
  file.path(fig_dir, "Bootstrap_Ratio_BRJ_Dim4.png")
))
```


### Percent Variance
```{r echo=TRUE}
# Sum of squares per component (block I and block J)
ssq.BR.I <- colSums(BR.I^2)
ssq.BR.J <- colSums(BR.J^2)

# Percent of total bootstrapâ€ratio variance captured by each component
pctVar.BR.I <- ssq.BR.I / sum(ssq.BR.I) * 100
pctVar.BR.J <- ssq.BR.J / sum(ssq.BR.J) * 100

# Print them (and pull out component 5 if you like)
print(pctVar.BR.I)
print(pctVar.BR.J)

# percent for dimension 1
pctVar.BR.I[1]
pctVar.BR.J[1]

```

################################################################ END ########################################################

### 4. Looking at the First Pair of Latent variables by site 

```{r}
# ploting the first latent variable of data1(X) and first latent variables of data2(Y). We are tryingto see if these two latent variables are similar or not.

# Extract design variable and ensure it's a factor (nominal)
data.design <- as.factor(covar_df$site_id_l)

# Convert to a matrix for PLSC input
data.design.vec <- as.matrix(data.design)
rownames(data.design.vec) <- covar_df$src_subject_id

# first pair of latent variables:

latvar.1 <- cbind(
  pls.res$TExPosition.Data$lx[, 1],
  pls.res$TExPosition.Data$ly[, 1]
)
table(data.design.vec)

colnames(latvar.1) <- c("Lx 1", "Ly 1")

# compute means
lv.1.group <- getMeans(latvar.1, data.design.vec)

# Assuming the data.design and latent variables (latvar.1) are already correctly set up

# Remove the color_site and related assignments
# col4Means <- as.matrix(color_site)  # This line can be removed
# rownames(col4Means) <- rownames(lv.1.group)  # This line can be removed

# You can assign a simple color (e.g., black) if you still need color
# If no color is needed, you can skip the col.points argument entirely
col4Means <- rep("black", nrow(lv.1.group))

# Compute bootstrap - for confidence intervals
lv.1.group.boot <- Boot4Mean(latvar.1, data.design.vec)
colnames(lv.1.group.boot$BootCube) <- c("Lx 1", "Ly 1")

# Ensure that row names are set to the correct subject IDs
rownames(latvar.1) <- covar_df$src_subject_id

```

```{r}
# Define the file path for saving the plot
factor_map <- paste0(fig_dir, "/factormap.png") # Ensure the slash before the file name

# Open the PNG device to save the plots with the specified dimensions
png(factor_map, height = 800, width = 1200, res = 100)

# Plotting your factor map
plot.lv1 <- createFactorMap(latvar.1,
  col.points = col4Means, # Assign color to points
  col.labels = col4Means, # Assign color to labels
  alpha.points = 0.7,
  force = 0.01
)

# Print the combined factor map components
print(plot.lv1$zeMap_background) # Plot background map
print(plot.lv1$zeMap_dots) # Plot points map
print(plot.lv1$zeMap_text) # Plot labels map

# Close the PNG device to save the file
dev.off() # Finalize and save the plot



```


plot1.mean <- createFactorMap(lv.1.group,
  col.points = col4Means, # Now using black for group means
  col.labels = col4Means, # Same for labels
  cex = 4,
  pch = 17,
  force = 0.1,
  alpha.points = 0.8
)

plot1.meanCI <- MakeCIEllipses(lv.1.group.boot$BootCube[, c(1:2), ], # Get the first two components
  col = col4Means[rownames(lv.1.group.boot$BootCube)],
  names.of.factors = c("Lx 1", "Ly 1")
)

plot1 <- plot.lv1$zeMap_background + plot.lv1$zeMap_dots + plot.lv1$zeMap_text + plot1.mean$zeMap_dots + plot1.mean$zeMap_text + plot1.meanCI
plot1

# Check for outliers
outlier <- subset(latvar.1, rowSums(latvar.1 > 0.3) > 0)

# Get the indices of outliers
indx <- which(rownames(latvar.1) == rownames(outlier))
print(rownames(outlier))

```


```{r}

colnames(latvar.1) <- c("Lx 1", "Ly 1")

# compute means
lv.1.group <- getMeans(latvar.1, data.design.vec)
print(lv.1.group)

col4Means <- as.matrix(color_site)
rownames(col4Means) <- rownames(lv.1.group)

# compute bootstrap - for confidence intervals
lv.1.group.boot <- Boot4Mean(latvar.1, data.design.vec)
colnames(lv.1.group.boot$BootCube) <- c("Lx 1", "Ly 1")

rownames(latvar.1) <- df_covariates$subjectkey

# plotiing the factor Maps
plot.lv1 <- createFactorMap(latvar.1,
  col.points = col4row,
  col.labels = col4row,
  alpha.points = 0.7,
  force = 0.01
)

plot1.mean <- createFactorMap(lv.1.group,
  col.points = col4Means,
  col.labels = col4Means,
  cex = 4,
  pch = 17,
  force = 0.1,
  alpha.points = 0.8
)

plot1.meanCI <- MakeCIEllipses(lv.1.group.boot$BootCube[, c(1:2), ], # get the first two components
  col = col4Means[rownames(lv.1.group.boot$BootCube)],
  names.of.factors = c("Lx 1", "Ly 1")
)

plot1 <- plot.lv1$zeMap_background + plot.lv1$zeMap_dots + plot.lv1$zeMap_text + plot1.mean$zeMap_dots + plot1.mean$zeMap_text + plot1.meanCI
plot1

# check for the outlier
outlier <- subset(latvar.1, rowSums(latvar.1 > 0.3) > 0)

indx <- which(rownames(latvar.1) == rownames(outlier))
print(rownames(outlier))

```

### 5. Obtaining Column factor scores

```{r echo=TRUE}
### Column Factor scores of the 1st component of data1 representing RSI measures and data2 representing air pollutants

# Fi:column factor scores for data1(RSI measures) or Loadings of data1(RSI measures)
Fi <- pls.res$TExPosition.Data$fi

# Fi:column factor scores for data2(Air pollutants exposure) or Loadings of data2(air pollutants exposure)
Fj <- pls.res$TExPosition.Data$fj

# Generating loadings map of Fi
p.loadings <- createFactorMap(Fi,
  axis1 = 1,
  axis2 = 2,
  display.points = TRUE,
  display.labels = T,
  col.points = col4column_rsi,
  col.labels = col4column_rsi,
  title = "Loadings of Columns RSI",
  pch = 20,
  cex = 3,
  text.cex = 3,
)

label4map <- createxyLabels.gen(
  x_axis = 1, y_axis = 2,
  lambda = pls.res$TExPosition.Data$eigs,
  tau = pls.res$TExPosition.Data$t
)

p.plot <- p.loadings$zeMap + label4map


p.plot

# Generating loadings map of Fj
q.loadings <- createFactorMap(Fj,
  axis1 = 1,
  axis2 = 2,
  display.points = TRUE,
  display.labels = TRUE,
  col.points = col4air,
  col.labels = col4air,
  title = "Loadings of Columns Air",
  pch = 20,
  cex = 3,
  text.cex = 4,
)

label4map <- createxyLabels.gen(
  x_axis = 1, y_axis = 2,
  lambda = pls.res$TExPosition.Data$eigs,
  tau = pls.res$TExPosition.Data$t
)

q.plot <- q.loadings$zeMap + label4map

q.plot
```

### 5. Column Loadings  

These are the loadings obtained after performing SVD(R) on correlation matrix.


```{r echo=TRUE}
# generating bar plots for loadings of RSI data table
P.data1 <- pls.res$TExPosition.Data$pdq$p


plot_P.data1 <- PrettyBarPlot2(
  bootratio = P.data1[, 1],
  threshold = 0,
  ylim = NULL,
  color4bar = gplots::col2hex(col4rsi),
  color4ns = "gray75",
  plotnames = TRUE,
  main = "Loadings of RSI variables",
  ylab = " P Loadings ",
  horizontal = TRUE
)


plot_P.data1

# generating bar plots for loadings of socio cultural data table
Q.data2 <- pls.res$TExPosition.Data$pdq$q


plot_Q.data2 <- PrettyBarPlot2(
  bootratio = Q.data2[, 1],
  threshold = 0,
  ylim = NULL,
  color4bar = gplots::col2hex(col4air),
  color4ns = "white",
  plotnames = TRUE,
  main = "Loadings of Air pollution variables",
  ylab = " Q Loadings "
)



plot_Q.data2

# saving the loading table into excel file.
socio_loadings <- as.data.frame(Q.data2)
rest_loadings <- as.data.frame(P.data1)

'''# saving the loading table into excel file.
df_loadings <- as.data.frame(c(P.data1[, 1], Q.data2[, 1]))

names(df_loadings) <- "Loadings(Dim1)"
df_loadings <- cbind(" " = rownames(df_loadings), df_loadings)
library("writexl")
write_xlsx(df_loadings, "D:\\USC\\Project1_4.0\\Analysis\\loadings_dim1.xlsx")'''
```

### 6. Inference Bootstrap


The Bootstrap ratio barplot show that the contributions are significantly stable.
```{r echo=TRUE}
# Looking into what the resBootPLSC is giving us
resBoot4PLSC <- Boot4PLSC(data1, # First Data matrix
  data2, # Second Data matrix
  nIter = 10000, # How many iterations
  Fi = pls.res$TExPosition.Data$fi,
  Fj = pls.res$TExPosition.Data$fj,
  nf2keep = 2.5,
  critical.value = 2.5,
  # To be implemented later
  # has no effect currently
  alphaLevel = 1
)

resBoot4PLSC
```



```{r echo=TRUE}
'''BR.I <- resBoot4PLSC$bootRatios.i
BR.J <- resBoot4PLSC$bootRatios.j

# saving the bootrap rations into excel

df_bootstrap <- as.data.frame(c(BR.I[, 1], BR.J[, 1]))

names(df_bootstrap) <- "Bootrap Ratios(Dim1)"
df_bootstrap <- cbind(" " = rownames(df_bootstrap), df_bootstrap)


write_xlsx(df_bootstrap, "D:\\USC\\Project1_4.0\\Analysis\\bootstrap_dim1.xlsx")




# bootstrap ratios for dimension 1
laDim <- 1

ba001.BR1.I <- PrettyBarPlot2(BR.I[, laDim],
  threshold = 2.5,
  font.size = 4,
  color4ns = "gray85",
  color4bar = col4rsi, # we need hex code
  ylab = "Bootstrap ratios"
  # ylim = c(1.2*min(BR[,laDim]), 1.2*max(BR[,laDim]))
) + ggtitle(paste0("Latent dimension ", laDim), subtitle = "RSI Grey Matter Saliences (Loadings)")

ba002.BR1.J <- PrettyBarPlot2(BR.J[, laDim],
  threshold = 2.5,
  font.size = 4,
  color4ns = "gray85",
  color4bar = gplots::col2hex(col4air),
  ylab = "Bootstrap ratios"
  # ylim = c(1.2*min(BR[,laDim]), 1.2*max(BR[,laDim]))
) + ggtitle(paste0("Latent dimension ", laDim), subtitle = "Air pollution Saliences (loadings)")

ba001.BR1.I
ba002.BR1.J'''
```

```{r echo=TRUE}
BR.I <- resBoot4PLSC$bootRatios.i
BR.J <- resBoot4PLSC$bootRatios.j


# bootstrap ratios for dimension 1
laDim <- 1

ba001.BR1.I <- PrettyBarPlot2(BR.I[, laDim],
  threshold = 3,
  font.size = 4,
  color4bar = col4rsi, # we need hex code
  ylab = "Bootstrap ratios"
  # ylim = c(1.2*min(BR[,laDim]), 1.2*max(BR[,laDim]))
) + ggtitle(paste0("Component ", laDim), subtitle = "Table 1")

ba002.BR1.J <- PrettyBarPlot2(BR.J[, laDim],
  threshold = 3,
  font.size = 4,
  color4bar = gplots::col2hex(col4air),
  ylab = "Bootstrap ratios"
  # ylim = c(1.2*min(BR[,laDim]), 1.2*max(BR[,laDim]))
) + ggtitle(paste0("Component ", laDim), subtitle = "Table 2")

ba001.BR1.I
ba002.BR1.J
```
